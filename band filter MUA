function hs_filterMUA(sessionPath)
% ========================================================================
%  funcAuto_filterMUAfromDat_v4(sessionPath)
%
%  Purpose :
%     Automatically extract & band-pass filter MUA (500‚Äì5000 Hz)
%     from wideband .dat for the WAKE epoch of a given session.
%
%  Key features :
%     ‚Ä¢ Safely clamps WAKE end to .dat file duration
%     ‚Ä¢ Skips short (<100 s) epochs
%     ‚Ä¢ Handles 20 kHz input ‚Üí 1250 Hz downsample
%     ‚Ä¢ Saves .MUA.mat file in session folder
%
%  Author : Husang (Harry) Lee, Buzs√°ki Lab
%  Updated: 2025-11-11
% ========================================================================

%% --- Setup & locate files ------------------------------------------------
if nargin < 1
    sessionPath = pwd;
end
cd(sessionPath);

fprintf('\nüìÇ Processing folder: %s\n', sessionPath);

% ---- Load session info ----
info = bz_getSessionInfo(sessionPath);
datFile = dir('*.dat');
if isempty(datFile)
    error('No .dat file found in %s', sessionPath);
end
datFilename = fullfile(sessionPath, datFile(1).name);
fprintf('Loaded %s | %d ch | fs=%d Hz | target=%d Hz\n', ...
    datFile(1).name, info.nChannels, info.rates.wideband, 1250);

%% --- Load sleep state file (WAKE epoch) ---------------------------------
stateFile = dir('*SleepState*.mat');
if isempty(stateFile)
    error('No SleepState file found in %s', sessionPath);
end
tmp = load(stateFile(1).name);
field = fieldnames(tmp);
SleepState = tmp.(field{1});  % supports SleepState or SleepStateClass
wakeEpochs = SleepState.ints.WAKEstate;

if isempty(wakeEpochs)
    warning('No WAKE epochs found. Skipping session.');
    return;
end

%% --- Compute recording duration from .dat size --------------------------
fileBytes = datFile(1).bytes;
recDur_sec = fileBytes / (info.nChannels * 2 * info.rates.wideband);
fprintf('Recording duration = %.2f s\n', recDur_sec);

% Use first WAKE epoch (typical SleepScoreMaster behavior)
wakeStart = wakeEpochs(1,1);
wakeEnd   = wakeEpochs(1,2);

% Clamp to file length
if wakeEnd > recDur_sec
    fprintf('‚ö†Ô∏è  Truncating WAKE end %.2f ‚Üí %.2f s (file limit)\n', ...
        wakeEnd, recDur_sec - 0.05);
    wakeEnd = recDur_sec - 0.05;
end

% Skip too-short epochs (<100 s)
wakeDur = wakeEnd - wakeStart;
if wakeDur < 100
    fprintf('‚è≠Ô∏è  WAKE epoch %.1f s < 100 s ‚Üí skipping session.\n', wakeDur);
    return;
else
    fprintf('Using WAKE window %.1f‚Äì%.1f s (%.1f s)\n', ...
        wakeStart, wakeEnd, wakeDur);
end

%% --- Band-pass filter MUA -----------------------------------------------
fsIn  = info.rates.wideband;
fsOut = 1250;
bpFilt = designfilt('bandpassiir','FilterOrder',4, ...
    'HalfPowerFrequency1',500,'HalfPowerFrequency2',5000, ...
    'SampleRate',fsIn);

startSample = round(wakeStart * fsIn);
endSample   = round(wakeEnd   * fsIn);

% Safety clamp against EOF
maxSample = floor(fileBytes / (info.nChannels * 2));
if endSample > maxSample
    fprintf('‚ö†Ô∏è  endSample > file length; truncating.\n');
    endSample = maxSample;
end

nCh = info.nChannels;
durationSec = (endSample - startSample) / fsIn;
fprintf('   ‚Üí Channel 1 of %d (%.1f s window)\n', nCh, durationSec);

% Preallocate (optional)
chunk = endSample - startSample + 1;
MUA_env = zeros(nCh, ceil(chunk * fsOut / fsIn), 'single');

for ch = 1:nCh
    try
        sig = bz_LoadBinary(datFilename, 'nChannels', nCh, ...
            'channels', ch-1, 'start', startSample, ...
            'duration', durationSec, 'frequency', fsIn);

        sigF = filtfilt(bpFilt, double(sig));
        sigD = resample(sigF, fsOut, fsIn);
        MUA_env(ch,:) = abs(hilbert(sigD)); % envelope
    catch ME
        warning('Error on ch %d: %s', ch, ME.message);
    end
end

%% --- Save output ---------------------------------------------------------
saveName = fullfile(sessionPath, ...
    sprintf('%s.MUA.mat', info.session.name));
save(saveName, 'MUA_env', 'fsOut', 'wakeStart', 'wakeEnd', '-v7.3');
fprintf('üíæ Saved %s\n', saveName);

end
