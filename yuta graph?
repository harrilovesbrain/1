function plot_MUA_LECdepth_singleShank(mouseName)
% ================================================================
%  Purpose : Plot averaged LEC MUA depth profile (single shank)
%  Normalization : Sum-normalized (∑ power = 1) following Yuta's MUA method
%  Author  : Husang (Harry) Lee, Buzsáki Lab
%  Last updated : 2025-11-04
% ================================================================

rootDir = fullfile('Z:\Buzsakilabspace\LabShare\JunH\Photometry', mouseName);
sessions = dir(fullfile(rootDir,'**','*.MUA.mat'));
if isempty(sessions), error('No MUA files found.'); end

nSessions = 0;
allMUA = [];

for i = 1:numel(sessions)
    muaPath = fullfile(sessions(i).folder, sessions(i).name);
    xmlPath = fullfile(sessions(i).folder, [sessions(i).name(1:end-8) '.xml']);
    if ~isfile(xmlPath)
        fprintf('⚠️  No XML for %s\n', sessions(i).name);
        continue;
    end

    % --- Load MUA ---
    S = load(muaPath);
    if ~isfield(S,'MUA') || ~isfield(S.MUA,'data')
        fprintf('⚠️  Invalid MUA in %s\n', sessions(i).name);
        continue;
    end
    MUA = S.MUA;

    % --- Parse last channel group (LEC shank) ---
    try
        xml = xml2struct(xmlPath);
        groups = xml.parameters.anatomicalDescription.channelGroups.group;
        if ~iscell(groups), groups = {groups}; end
        lecIdx = numel(groups);
        grp = groups{lecIdx};
        chans = grp.channel;
        if ~iscell(chans), chans = {chans}; end
        lecCh = [];
        for k = 1:numel(chans)
            node = chans{k};
            if isfield(node,'id')
                lecCh(end+1) = str2double(node.id.Text);
            elseif isfield(node,'Attributes') && isfield(node.Attributes,'id')
                lecCh(end+1) = str2double(node.Attributes.id);
            else
                lecCh(end+1) = k-1;
            end
        end
        lecCh = lecCh + 1;
    catch
        fprintf('⚠️  XML parse error in %s\n', sessions(i).name);
        continue;
    end

    % --- Fallback geometry 0–1280 µm (20 µm spacing) ---
    spacing = 20;
    N = numel(lecCh);
    lecY = (0:N-1)*spacing;
    lecY = lecY * (1280 / max(lecY));

    % --- Compute normalized MUA power (sum-normalized) ---
    validCh = lecCh(lecCh <= size(MUA.data,2));
    meanPower = mean(MUA.data(:,validCh),1);
    if all(meanPower == 0), continue; end

    % remove NaN or negative
    meanPower(meanPower < 0 | isnan(meanPower)) = 0;

    % --- Band-limit normalization (Yuta-style probability) ---
    normPower = meanPower / sum(meanPower);  % sum = 1

    % --- Interpolate and smooth ---
    fullDepth = linspace(0,1280,400);
    interpMUA = interp1(lecY, normPower, fullDepth, 'pchip', 'extrap');
    smoothed  = smoothdata(interpMUA,'gaussian',25);

    % --- Store ---
    nSessions = nSessions + 1;
    allMUA(nSessions,:) = smoothed;
    if nSessions==1, refDepth = fullDepth; end
    fprintf('✅ Included: %s\n', sessions(i).name);
end

if nSessions==0
    warning('No valid sessions for %s.', mouseName);
    return;
end

% --- Average across sessions ---
meanMUA = mean(allMUA,1);
semMUA  = std(allMUA,[],1)/sqrt(nSessions);

% --- Normalize again to ensure sum = 1 ---
meanMUA = meanMUA / sum(meanMUA);
semMUA  = semMUA / sum(meanMUA);

% --- Plot (Yuta-style: deep region focus) ---
figure('Color','w','Position',[300 200 420 600]); hold on;
fill([meanMUA-semMUA, fliplr(meanMUA+semMUA)], ...
     [refDepth, fliplr(refDepth)], [0.8 0.8 0.8], ...
     'EdgeColor','none','FaceAlpha',0.4);
plot(meanMUA, refDepth, 'k', 'LineWidth', 2.5);

set(gca,'YDir','reverse','Box','off','TickDir','out',...
    'FontSize',12,'LineWidth',1);
xlabel('Normalized MUA power (sum = 1, 500 Hz – 5 kHz)','FontSize',12);
ylabel('Depth (µm)','FontSize',12);
title(sprintf('LEC MUA depth (1 shank) — %s (n = %d sessions)', ...
      mouseName, nSessions),'FontWeight','normal','FontSize',12);
ylim([800 1300]);   % zoom on deep LEC region
xlim([0 max(meanMUA)*1.1]);
set(gca,'Layer','top');

fprintf('\n✅ Finished: %d sessions averaged (sum-normalized to 1)\n', nSessions);
end
