function plot_MUA_LECdepth(mouseName)
% ================================================================
%  Purpose: Average MUA depth profile (LEC region only)
%  Notes:
%   • Compatible with modern BuzsakiLab XML format:
%       xml.parameters.anatomicalDescription.channelGroups.group.channel
%   • Handles duplicate depth values automatically
%   • Produces Yuta-style smooth mean ± SEM plot
% ================================================================

rootDir = fullfile('Z:\Buzsakilabspace\LabShare\JunH\Photometry', mouseName);
sessions = dir(fullfile(rootDir, '**', '*.MUA.mat'));
nSessions = 0;

commonDepth = linspace(0, 1300, 200); % µm range for LEC region
MUA_all = nan(numel(sessions), numel(commonDepth)); % preallocate

for i = 1:numel(sessions)
    muaPath = fullfile(sessions(i).folder, sessions(i).name);
    xmlPath = fullfile(sessions(i).folder, [sessions(i).name(1:end-8) '.xml']);

    % --- Skip sessions missing XML ---
    if ~isfile(xmlPath)
        fprintf('⚠️ Skipping: %s (no XML found)\n', sessions(i).name);
        continue;
    end

    % --- Load MUA data ---
    dataStruct = load(muaPath);
    if ~isfield(dataStruct, 'MUA') || ~isfield(dataStruct.MUA, 'data')
        fprintf('⚠️ Skipping: %s (no valid MUA data)\n', sessions(i).name);
        continue;
    end
    MUA = dataStruct.MUA;

    % --- Parse electrode geometry (modern XML structure) ---
    try
        xml = xml2struct(xmlPath);
        groups = xml.parameters.anatomicalDescription.channelGroups.group;
        if ~iscell(groups)
            groups = {groups};
        end

        % use last two groups as LEC region
        lecIdx = max(1, numel(groups)-1):numel(groups);
        lecCh = [];
        lecY  = [];

        for gi = lecIdx
            grp = groups{gi};
            chans = grp.channel;
            if ~iscell(chans)
                chans = {chans};
            end

            for k = 1:numel(chans)
                chNode = chans{k};

                % --- Channel ID ---
                if isfield(chNode, 'id')
                    lecCh(end+1) = str2double(chNode.id.Text);
                elseif isfield(chNode, 'Attributes') && isfield(chNode.Attributes, 'id')
                    lecCh(end+1) = str2double(chNode.Attributes.id);
                else
                    lecCh(end+1) = k-1; % fallback
                end

                % --- Depth (y coordinate) ---
                if isfield(chNode, 'y')
                    lecY(end+1) = str2double(chNode.y.Text);
                elseif isfield(chNode, 'Attributes') && isfield(chNode.Attributes, 'y')
                    lecY(end+1) = str2double(chNode.Attributes.y);
                else
                    lecY(end+1) = k * 20; % fallback spacing
                end
            end
        end

    catch ME
        fprintf('⚠️ Skipping: %s (XML parse error: %s)\n', sessions(i).name, ME.message);
        continue;
    end

    % --- Sort and map ---
    [lecY, sortIdx] = sort(lecY);
    lecCh = lecCh(sortIdx) + 1; % MATLAB 1-indexed

    validCh = lecCh(lecCh <= size(MUA.data,2));
    if isempty(validCh)
        fprintf('⚠️ Skipping: %s (no matching channels)\n', sessions(i).name);
        continue;
    end

    % --- Compute normalized power ---
    meanPower = mean(MUA.data(:,validCh),1);
    normPower = meanPower / max(meanPower);

    % --- Handle duplicate depths before interpolation ---
    [uniqueY, ~, ic] = unique(lecY(1:numel(normPower)));
    if numel(uniqueY) < 2
        fprintf('⚠️ Skipping: %s (insufficient unique depth points)\n', sessions(i).name);
        continue;
    end

    avgPower = accumarray(ic(:), normPower(:), [], @mean);

    % --- Interpolate to common depth grid ---
    interpMUA = interp1(uniqueY, avgPower, commonDepth, 'pchip', 'extrap');

    % --- Smooth along depth ---
    smoothed = smoothdata(interpMUA, 'gaussian', 10);

    % --- Store for averaging ---
    nSessions = nSessions + 1;
    MUA_all(nSessions,:) = smoothed;
    fprintf('✅ Included: %s\n', sessions(i).name);
end

% --- Check for valid sessions ---
if nSessions == 0
    warning('No valid sessions found for %s.', mouseName);
    return;
end

% --- Trim unused rows ---
MUA_all = MUA_all(1:nSessions, :);

% --- Average across sessions ---
meanMUA = mean(MUA_all,1);
semMUA  = std(MUA_all,[],1)/sqrt(nSessions);

% --- Plot like Yuta Fig. H ---
% --- Yuta-style mean ± SEM plot ---
figure('Color','w','Position',[200 200 400 600]); hold on;

% shaded SEM (light gray, subtle transparency)
fill([meanMUA-semMUA, fliplr(meanMUA+semMUA)], ...
     [commonDepth, fliplr(commonDepth)], ...
     [0.7 0.7 0.7], 'EdgeColor','none', 'FaceAlpha', 0.4);

% mean trace (thick black line)
plot(meanMUA, commonDepth, 'k', 'LineWidth', 2.5);

% axes style
set(gca, 'YDir','reverse', ...
         'Box','off', ...
         'TickDir','out', ...
         'FontSize',12, ...
         'LineWidth',1, ...
         'XColor','k','YColor','k', ...
         'YLim',[0 1300], ...
         'XLim',[0 1.05]);

xlabel('Normalized MUA power (500 Hz – 5 kHz)', 'FontSize',12);
ylabel('Depth (µm)', 'FontSize',12);
title(sprintf('LEC MUA depth profile (n = %d sessions)', nSessions), ...
      'FontWeight','normal','FontSize',12);

% minimalistic grid (optional)
set(gca,'Layer','top');
